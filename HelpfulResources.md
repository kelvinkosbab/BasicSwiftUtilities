# Helpful Resources

## What are the differences between `struct` vs `class`?

Structures and classes are good choices for storing data and modeling behavior in your apps, but
their similarities can make it difficult to choose one over the other.

Consider the following recommendations to help choose which option makes sense when adding a new
data type to your app.

- Use structures by default.
- Use classes when you need Objective-C interoperability.
- Use classes when you need to control the identity of the data you’re modeling.
- Use structures along with protocols to adopt behavior by sharing implementations.

More resources:
 - Apple Developer's [Choosing Between Structures and Classes documentation](https://developer.apple.com/documentation/swift/choosing-between-structures-and-classes).
 - Antoine Van Der Lee's post [Struct vs classes in Swift: The differences explained](https://www.avanderlee.com/swift/struct-class-differences/).

## Automatic Reference Counting (ARC) vs Garbage Collection

### Automatic Reference Counting (ARC)

Swift uses Automatic Reference Counting (ARC) to track and manage your app’s memory usage. In most
cases, this means that memory management “just works” in Swift, and you don’t need to think about
memory management yourself. ARC automatically frees up the memory used by class instances when those
instances are no longer needed.

Reference counting applies only to instances of classes. Structures and enumerations are value
types, not reference types, and aren’t stored and passed by reference.

Every time you create a new instance of a class, ARC allocates a chunk of memory to store
information about that instance. This memory holds information about the type of the instance,
together with the values of any stored properties associated with that instance.

Additionally, when an instance is no longer needed, ARC frees up the memory used by that instance
so that the memory can be used for other purposes instead. This ensures that class instances don’t
take up space in memory when they’re no longer needed.

For more information see [Swift's documentation for Automatic Reference Counting](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/automaticreferencecounting/#)
and [Wikipedia's reference on Automatic Reference Counting](https://en.wikipedia.org/wiki/Automatic_Reference_Counting).

### Garbage Collection

In computer science, garbage collection (GC) is a form of automatic memory management. The garbage
collector attempts to reclaim memory which was allocated by the program, but is no longer
referenced; such memory is called garbage.

Garbage collection relieves the programmer from doing manual memory management, where the programmer
specifies what objects to de-allocate and return to the memory system and when to do so.

For more information see [Garbage Collection Wikipedia reference](https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)).

#### Advantages

GC frees the programmer from manually de-allocating memory. This helps avoid some kinds of errors:

- Dangling pointers, which occur when a piece of memory is freed while there are still pointers to
it, and one of those pointers is dereferenced. By then the memory may have been reassigned to
another use, with unpredictable results.
- Double free bugs, which occur when the program tries to free a region of memory that has already
been freed, and perhaps already been allocated again.
- Certain kinds of memory leaks, in which a program fails to free memory occupied by objects that
have become unreachable, which can lead to memory exhaustion.

#### Disadvantages

GC uses computing resources to decide which memory to free. Therefore, the penalty for the
convenience of not annotating object lifetime manually in the source code is overhead, which can
impair program performance. A peer-reviewed paper from 2005 concluded that GC needs five times the
memory to compensate for this overhead and to perform as fast as the same program using idealised
explicit memory management. The comparison however is made to a program generated by inserting
deallocation calls using an oracle, implemented by collecting traces from programs run under a
profiler, and the program is only correct for one particular execution of the program. Interaction
with memory hierarchy effects can make this overhead intolerable in circumstances that are hard to
predict or to detect in routine testing. The impact on performance was given by Apple as a reason
for not adopting garbage collection in iOS, despite it being the most desired feature.

The moment when the garbage is actually collected can be unpredictable, resulting in stalls (pauses
to shift/free memory) scattered throughout a session. Unpredictable stalls can be unacceptable in
real-time environments, in transaction processing, or in interactive programs. Incremental,
concurrent, and real-time garbage collectors address these problems, with varying trade-offs. 

## Common communication and data transmission patterns

1. Delegation
2. Notifications
3. Key value observing

### Delegation

The basic idea of delegation, is that a controller defines a protocol (a set of method definitions)
that describe what a delegate object must do in order to be allowed to respond to a controller’s
events. The protocol is a contract where the delegator says “If you want to be my delegate, then
you must implement these methods”.

**Pros:**
- All events to be heard are clearly defined in the delegate protocol.
- Errors are not repelled as it should be by a delegate.
- Protocol defined within the scope of the controller only.
- Very traceable, and easy to identify flow of control within an application.
- No third party object required to maintain / monitor the communication process.

**Cons:**
- Many lines of code required to define: 1. the protocol definition, 2. the delegate property in
the controller, and 3. the implementation of the delegate method definitions within the delegate itself.
- Need to be careful to correctly set delegates to `nil` on object deallocation, failure to do so
can cause memory crashes by calling methods on deallocated objects.
- Although possible, it can be difficult and the pattern does not really lend itself to have
multiple delegates of the same protocol in a controller (telling multiple objects about the same event)

### Notifications

In iOS applications there is a concept of a “Notification Center”. The main feature of this
pattern is that the sender and recipients (there can be many) do not talk directly, like with
delegate pattern. Instead, they both talk to `NotificationCenter` - the sender calls method
`postNotification` on the `NotificationCenter` to send a notification, while recipients opt-in
for receiving the notifications by calling `addObserver` on `NotificationCenter`. They can
later opt-out with `removeObserver`. Important note though is that NotificationCenter does
not store notifications for future subscribers - only present subscribers receive the
notifications.

**Pros:**
- Easy to implement, with not many lines of code.
- Can easily have multiple objects reacting to the same notification being posted.
- Controller can pass in a context (dictionary) object with custom information (`userInfo`)
related to the notification being posted.

**Cons:**
- No compile time to checks to ensure that notifications are correctly handled by observers.
- Battery leackage or it uses more memory.
- Required to un-register with the notification center if your previously registered object
is deallocated.
- Third party object required to manage the link between controllers and observer objects.
- Notification Names, and UserInfo dictionary keys need to be known by both the observers
and the controllers. If these are not defined in a common place, they can very easily
become out of sync.

### Observation

`KVO` is a traditional [observer pattern](https://en.wikipedia.org/wiki/Observer_pattern) built-in
any `NSObject` out of the box. With `KVO` observers can be notified of any changes of a `@property`
values. It leverages Objective-C runtime for automated notifications dispatch, and because of that
for Swift class, you would need to opt into Objective-C dynamism by inheriting `NSObject` and marking
the `var` you’re going to observe with modifier dynamic. The observers should also be `NSObject`
descendants because this is enforced by the `KVO` API.

**Pros:**
- Can provide an easy way to sync information between two objects. For example, a model and a view.
- Allows us to respond to state changes inside objects that we did not create, and don’t have
access to alter the implementations of (SKD objects).
- Can provide us with the new value and previous value of the property we are observing.
- Can use key paths to observe properties, thus nested objects can be observed.

**Cons:**
- The properties we wish to observe, must be defined using strings. Thus no compile time
warnings or checking occurs.
- Re-factoring of properties can leave our observation code no longer working.
- Complex “IF” statements required if an object is observing multiple values.
- Need to remove the observer when it is deallocated.

# Useful Learning Resources

Getting into a new software stack can be overwhelming. Here are some resources I have found
useful for understanding core concepts of developing on Apple Platforms and develpoing with
the Swift programming language.

## Kodeco / Ray Wenderlich

RayWenderlich (rebranded to Kodeco) have been providing useful programming resources for 
more than a decade. This site is one of the best investments for mobile developers.

See [Kodeco's iOS and Swift Start Page](https://www.kodeco.com/ios/paths/learn).

## Hacking with Swift

With more free Swift tutorials than any other site, Hacking with Swift will help you
learn app development with UIKit and SwiftUI.

See [hackingwithswift.com](https://www.hackingwithswift.com).

## The Wisdom of Quinn

The [Wisdom of Quinn GitHub page](https://github.com/macshome/The-Wisdom-of-Quinn) provides
resources for just about everyting for developering on Apple's platforms including but by no
means limited to:
- [Code Signing](https://github.com/macshome/The-Wisdom-of-Quinn#code-signing)
- [Distribution](https://github.com/macshome/The-Wisdom-of-Quinn#distribution)
- [File Systems](https://github.com/macshome/The-Wisdom-of-Quinn#filesystems)
- [Security](https://github.com/macshome/The-Wisdom-of-Quinn#security)
- [Logging](https://github.com/macshome/The-Wisdom-of-Quinn#logging)
- and much... much more...

## Swift concurrency resources

- [Async await in Swift explained with code examples](https://www.avanderlee.com/swift/async-await/)
- [Actors in Swift: how to use and prevent data races](https://www.avanderlee.com/swift/actors/)
- [Swift actors: How do they work, and what kinds of problems do they solve?](https://www.swiftbysundell.com/articles/swift-actors/)
- [Sendable and @Sendable closures explained with code examples](https://www.avanderlee.com/swift/sendable-protocol-closures/)

## SwiftUI resources

- [SwiftUI Button Tutorial: Customization](https://www.kodeco.com/34851726-swiftui-button-tutorial-customization)

## Other resources

- [MVVM Architectural Design Pattern in Swift](https://medium.com/dev-genius/mvvm-architectural-design-pattern-in-swift-87dde74758b0)
- [VIPER Design Pattern in Swift](https://blog.devgenius.io/viper-design-pattern-with-a-basic-example-2a5802f6e6f1)
- [Haacking with Swift interview questions](https://www.hackingwithswift.com/interview-questions)
- [iOS Interview Guide: Questions for Senior Developers](https://iosinterviewguide.com/ios-interview-questions-for-senior-developers-in-2020)
